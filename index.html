<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sumud Flotilla status</title>
  <!-- Open Graph -->
  <meta property="og:title" content="Sumud Flotilla status" />
  <meta property="og:description" content="An updated map every 30 minutes, to see the latest position of the flotilla's ships." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://aborruso.github.io/sumud_flotilla/" />
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Sumud Flotilla status" />
  <meta name="twitter:description" content="An updated map every 30 minutes, to see the latest position of the flotilla's ships." />
  <meta name="twitter:url" content="https://aborruso.github.io/sumud_flotilla/" />
  <!-- MapLibre GL JS (jsDelivr) -->
  <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100vw; height: 100vh; }
    .maplibregl-popup-content { font-size: 1rem; }
  </style>
</head>
<body class="bg-gray-100">
  <div id="map"></div>

  <!-- Controlli custom -->
  <div class="absolute top-4 right-4 z-20 flex flex-col gap-2">
    <button id="zoomToFitBtn" class="bg-white border border-gray-300 rounded px-3 py-1 shadow font-bold hover:bg-blue-100">Zoom to fit</button>
    <button id="openVesselListBtn" class="bg-white border border-gray-300 rounded px-3 py-1 shadow font-bold hover:bg-blue-100">Vessels List</button>
  </div>

  <!-- Modale lista vascelli -->
  <div id="vesselModal" class="fixed inset-0 z-30 flex items-center justify-center bg-black bg-opacity-60 hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="closeModalBtn" class="absolute top-2 right-2 text-2xl text-gray-500 hover:text-gray-800">&times;</button>
      <h2 class="text-xl font-bold mb-4">Vessels List</h2>
      <input id="vesselSearchInput" type="text" placeholder="Search vessels..." class="w-full border border-gray-300 rounded px-3 py-2 mb-3" />
      <div class="max-h-80 overflow-y-auto">
        <table class="w-full text-left">
          <thead><tr><th class="py-2 border-b text-gray-500">Vessel Name</th></tr></thead>
          <tbody id="vesselTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Source box -->
  <div id="sourceBox" class="fixed bottom-4 left-4 z-20 bg-white text-black px-3 py-1 rounded shadow text-xs flex items-center">
    <a href="https://globalsumudflotilla.org/tracker/" target="_blank" class="font-bold text-blue-700 underline">Source</a>
    <span id="lastUpdate" class="ml-2 text-gray-600"></span>
  </div>

  <script>
    // Configurazione mappa
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://tiles.stadiamaps.com/styles/alidade_smooth.json',
      center: [12, 37],
      zoom: 5,
      attributionControl: true
    });
    map.addControl(new maplibregl.NavigationControl(), 'top-left');

    // Stato globale
    let vesselList = [];
    let clusterSourceId = 'vessels';
    let popup = null;

    // Carica vessels.json e aggiorna mappa
    async function loadVessels() {
      const resp = await fetch('vessels.json');
      const json = await resp.json();
      // Estraggo la posizione piÃ¹ recente per ogni nave
      vesselList = (json.vessels || []).map(v => {
        const lastPos = Array.isArray(v.positions) && v.positions.length > 0 ? v.positions[v.positions.length - 1] : null;
        return {
          id: v.id,
          name: v.name,
          status: v.status,
          type: v.type || '-',
          mmsi: v.mmsi || '-',
          last_update: lastPos ? lastPos.timestamp_utc : '-',
          lat: lastPos ? lastPos.latitude : null,
          lon: lastPos ? lastPos.longitude : null
        };
      }).filter(v => v.lat !== null && v.lon !== null);
      vesselList.sort((a, b) => a.name.localeCompare(b.name));
      renderVesselTable(vesselList);
      addVesselSourceToMap();
    }

    // Carica timestamp aggiornamento
    async function loadLastUpdate() {
      try {
        const resp = await fetch('last_updated.txt');
        const txt = await resp.text();
        document.getElementById('lastUpdate').textContent = `(data map update: ${txt.trim()})`;
      } catch {}
    }

    // Aggiungi i dati come source geojson e layer cluster
    function addVesselSourceToMap() {
      if (map.getSource(clusterSourceId)) map.removeSource(clusterSourceId);
      if (map.getLayer('clusters')) map.removeLayer('clusters');
      if (map.getLayer('cluster-count')) map.removeLayer('cluster-count');
      if (map.getLayer('unclustered-point')) map.removeLayer('unclustered-point');

      const features = vesselList.map(v => ({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [v.lon, v.lat] },
        properties: { ...v }
      }));
      map.addSource(clusterSourceId, {
        type: 'geojson',
        data: { type: 'FeatureCollection', features },
        cluster: true,
        clusterMaxZoom: 14,
        clusterRadius: 50
      });
      // Cluster layer
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: clusterSourceId,
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#1976D2',
          'circle-radius': [ 'step', ['get', 'point_count'], 18, 10, 24, 30, 32 ],
          'circle-opacity': 0.7
        }
      });
      // Cluster count
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: clusterSourceId,
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 14
        },
        paint: { 'text-color': '#fff' }
      });
      // Unclustered points
      map.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: clusterSourceId,
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#1976D2',
          'circle-radius': 6,
          'circle-stroke-width': 2,
          'circle-stroke-color': '#1976D2'
        }
      });
      // Popup su click marker
      map.on('click', 'unclustered-point', function(e) {
        const props = e.features[0].properties;
        showVesselPopup(props, e.features[0].geometry.coordinates);
      });
      // Zoom su cluster
      map.on('click', 'clusters', function(e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
        const clusterId = features[0].properties.cluster_id;
        map.getSource(clusterSourceId).getClusterExpansionZoom(clusterId, function (err, zoom) {
          if (err) return;
          map.easeTo({ center: features[0].geometry.coordinates, zoom });
        });
      });
      // Cambia il cursore
      map.on('mouseenter', 'clusters', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'clusters', () => map.getCanvas().style.cursor = '');
      map.on('mouseenter', 'unclustered-point', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'unclustered-point', () => map.getCanvas().style.cursor = '');
      // Fit bounds
      zoomToFit();
    }

    // Mostra popup vessel
    function showVesselPopup(props, coords) {
      if (popup) popup.remove();
      const lastUpdate = props.last_update ? props.last_update.replace('T', ' ').slice(0, 19) : '-';
      const status = props.status || '-';
      const type = props.type || '-';
      popup = new maplibregl.Popup({ closeOnClick: true })
        .setLngLat(coords)
        .setHTML(`
          <div class="p-2">
            <h3 class="font-bold text-lg">${props.name}</h3>
            <p class="text-xs text-gray-500">Last update: ${lastUpdate}</p>
            <div class="mt-2 text-sm">
              <p><span class="font-semibold">Status:</span> ${status}</p>
              <p><span class="font-semibold">Type:</span> ${type}</p>
            </div>
          </div>
        `)
        .addTo(map);
    }

    // Vessel List Modal
    const vesselModal = document.getElementById('vesselModal');
    const openVesselListBtn = document.getElementById('openVesselListBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const vesselSearchInput = document.getElementById('vesselSearchInput');
    const vesselTableBody = document.getElementById('vesselTableBody');
    openVesselListBtn.onclick = () => { vesselModal.classList.remove('hidden'); renderVesselTable(vesselList); };
    closeModalBtn.onclick = () => vesselModal.classList.add('hidden');
    vesselModal.onclick = e => { if (e.target === vesselModal) vesselModal.classList.add('hidden'); };
    vesselSearchInput.onkeyup = e => {
      const term = e.target.value.toLowerCase();
      renderVesselTable(vesselList.filter(v => v.name.toLowerCase().includes(term)));
    };
    function renderVesselTable(vessels) {
      vesselTableBody.innerHTML = '';
      vessels.forEach(vessel => {
        const row = document.createElement('tr');
        row.className = 'cursor-pointer hover:bg-blue-50';
        row.innerHTML = `<td class="py-2 border-b">${vessel.name}</td>`;
        row.onclick = () => {
          vesselModal.classList.add('hidden');
          map.flyTo({ center: [vessel.lon, vessel.lat], zoom: 15 });
          setTimeout(() => {
            showVesselPopup(vessel, [vessel.lon, vessel.lat]);
          }, 600);
        };
        vesselTableBody.appendChild(row);
      });
    }

    // Zoom to fit
    function zoomToFit() {
      if (!vesselList.length) return;
      const lats = vesselList.map(v => v.lat);
      const lons = vesselList.map(v => v.lon);
      const bounds = [
        [Math.min(...lons), Math.min(...lats)],
        [Math.max(...lons), Math.max(...lats)]
      ];
      map.fitBounds(bounds, { padding: 60, duration: 800 });
    }
    document.getElementById('zoomToFitBtn').onclick = zoomToFit;

    // Stato URL hash
    map.on('moveend', () => {
      const c = map.getCenter();
      const z = map.getZoom();
      window.location.hash = `${z.toFixed(2)}/${c.lat.toFixed(5)}/${c.lng.toFixed(5)}`;
    });
    window.addEventListener('DOMContentLoaded', () => {
      // Ripristina stato da hash
      const hash = window.location.hash;
      if (hash) {
        const parts = hash.substring(1).split('/');
        if (parts.length === 3) {
          const zoom = parseFloat(parts[0]);
          const lat = parseFloat(parts[1]);
          const lon = parseFloat(parts[2]);
          if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lon)) {
            map.setCenter([lon, lat]);
            map.setZoom(zoom);
          }
        }
      }
      loadVessels();
      loadLastUpdate();
    });
  </script>
</body>
</html>
